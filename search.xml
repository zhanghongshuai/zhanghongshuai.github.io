<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[匿名内部类或Lambda表达式使用局部变量]]></title>
    <url>%2F2017%2F11%2F27%2F%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%88%96Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[引言匿名内部类或Lambda表达式使用外部局部变量时，要求这些局部变量必须是由final的，虽然Java8的lambda表达式使用的外部局部变量可以没有final修饰，但是该变量和加了final修饰的变量一样，不能在声明后被修改，为什么？ 代码示例用于构造匿名内部类的Fly接口：12345678package anonymouseInnerClass;/** * Created by hongshuai.zhang on 2017/11/27 下午1:31 */public interface Fly &#123; void fly();&#125; 包含main方法的主类Runner：123456789101112131415161718package anonymouseInnerClass;/** * Created by hongshuai.zhang on 2017/11/27 下午1:31 */public class Runner &#123; public static void main(String[] args) &#123; final String name = "goose"; final int meters = 1; Fly goose = new Fly() &#123; @Override public void fly() &#123; System.out.println(name + " can fly " + meters + " meters."); &#125; &#125;; goose.fly(); &#125;&#125; 运行结果如下：1goose can fly 1 meters. 如果去掉了Runner类main方法中的两个局部变量的final修饰符，编译报错，错误内容为：12Error:(12, 28) java: 从内部类中访问本地变量name; 需要被声明为最终类型Error:(12, 49) java: 从内部类中访问本地变量meters; 需要被声明为最终类型 如果去掉了两个final修饰符，但是将匿名内部类的写法换成了Lambda表达式的方式，即：1Fly goose = () -&gt; System.out.println(name + " can fly " + meters + " meters."); 程序也是能正常运行的，但是如果在Lambda中修改了这两个变量的值，譬如：1234Fly goose = () -&gt; &#123; name = "bird"; System.out.println(name + " can fly " + meters + " meters."); &#125;; 程序会报错：1Error:(11, 7) java: 无法为最终变量name分配值 根据这个错误提示，可以得出：lambda表达式中使用的局部变量可以不用final修饰只是形式上的改变，编译后，这些变量还是当做final变量来对待的。综上，无论匿名内部类还是lambda表达式中使用外部局部变量时，要求局部变量必须是final的，为什么呢？ 原因生命周期 mismatch我们知道，在方法内部定义的局部变量，其生命周期和方法的生命周期一样，随着方法的出栈而销毁，但是匿名内部类和lambda表达式属于对象，其生命周期由JVM管理，而且很多情况下，匿名内部类或者lambda表达式作为方法的返回值使用，这就导致了匿名内部类（或lambda表达式）的生命周期和局部变量的生命周期不一致，为了保证方法出栈后，匿名内部类或者lambda表达式仍能使用局部变量，Java将局部变量浅拷贝了一份给匿名内部类，并使之作为匿名内部类的成员变量使用。噢，对了，匿名内部类在编译后，会生成一个单独的字节码文件，上文Runner类中goose内部类的字节码文件反编译后如下：12345678final class Runner$1 implements Fly &#123; Runner$1() &#123; &#125; public void fly() &#123; System.out.println("goose can fly 1 meters."); &#125;&#125; 我用的是JDK1.8，编译和反编译后发现，编译后name和meters变量直接当做常量来使用了，没有体现出来上文解释的那样：局部变量被copy一份给匿名内部类，并以内部类的成员变量的形式存在。因此，编写了新的Runner类,其源码和反编译内容如下：12345678910111213141516171819202122232425import java.util.Arrays;import java.util.List;/** * Created by hongshuai.zhang on 2017/11/27 下午9:29 */public class Runner &#123; public static void main(String[] args) &#123; List&lt;String&gt; birds = Arrays.asList(new String[]&#123; "bird", "goose" &#125;); Fly goose = new Fly() &#123; @Override public void fly() &#123; for (String bird : birds) &#123; System.out.println(bird + "can fly."); &#125; &#125; &#125;; goose.fly(); &#125;&#125; 123456789101112131415161718192021import java.util.Iterator;import java.util.List;final class Runner$1 implements Fly &#123; List val$birds; //IDEA反编译没有展示出来，为了增加理解，手动加上的 Runner$1(List var1) &#123; this.val$birds = var1; &#125; public void fly() &#123; Iterator var1 = this.val$birds.iterator(); while(var1.hasNext()) &#123; String bird = (String)var1.next(); System.out.println(bird + "can fly."); &#125; &#125;&#125; 由字节码分析可知，局部变量通过构造器函数传递给了匿名内部类的成员变量，由此可以解决局部变量和匿名内部类或labmda表达式之间生命周期mismatch的问题 必须final么？当然了，局部变量被浅拷贝了一份到匿名内部类（或lambda表达式）中，因此为了保证两者数据的一致性，就得强制限制匿名内部类或lambda表达式）使用的局部变量必须是final的，即不能在匿名内部类或者匿名内部类外对局部变量进行赋值，否则会导致匿名内部类中的变量和内部类外的变量数据不一致的问题。本来就是同一个变量，却有两个不同的值，在语义上是说不过去哒~ 彩蛋通过foreach循环的反编译知道，foreach和迭代器在编译后是一个东西，只是编码上foreach更方便，这也是为什么只有实现了Iterable接口的类才能使用foreach循环~ 以上。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
      </tags>
  </entry>
</search>
